The peer-to-peer network distributes the full blockchain database across the
world. It consists of public and private nodes as well as seed nodes that are
used for initial connection to the peer-to-peer network. Anybody may connect to
any known node and download the current global and unique state (i.e. the
blockchain).

Once a node is in sync with the peer-to-peer network it received and applies
newly created blocks, and assists new network nodes by further distribution of
the blockchain. Additionally, new blocks are broadcast to all connected nodes.

Furthermore, network nodes receive transaction from participants and forward
them to the rest of the network until they reach the witness that is in charge
of constructing the next block. Hence, new transaction broadcasts do not
necessarily need to reach all nodes.

On reception of new transactions by a witness node, the witness validates its
operations and advances the blockchain state by one block containing that
transaction (and possibly many more).

If a node does not receive a block, it will request it when it receives the
next block and realizes it missed one. If a witness did not receive its
previous block at the time it is supposed to construct its block, the previous
block will be marked as \emph{missed} and a reference to the block before the
previous block will be used instead. A more detailed description about the
distributed consensus mechanism as well as a discussion how blockchain forking
is prevented during attacks is given in a separate paper~\cite{}. % FIXME link dpos paper



% # Network Protocol 2
% 
% Building a low-latency network requires P2P nodes that have low-latency
% connections and a protocol designed to minimize latency. for the purpose
% of this document we will assume that two nodes are located on opposite
% sides of the globe with a ping time of 250ms.   
% 
% 
% ## Announce, Request, Send Protocol
% Under the prior network archtiecture, transactions and blocks were broadcast
% in a manner similar to the Bitcoin protocol: inventory messages notify peers of
% transactions and blocks, then peers fetch the transaction or block from one
% peer.  After validating the item a node will broadcast an inventory message to
% its peers.
% 
% Under this model it will take 0.75 seconds for a peer to communicate a transaction
% or block to another peer even if their size was 0 and there was no processing overhead.
% This level of performance is unacceptable for a network attempting to produce one block
% every second.
% 
% This prior protocol also sent every transaction twice: initial broadcast, and again as
% part of a block. 
% 
% 
% ## Push Protocol
% To minimize latency each node needs to immediately broadcast the data it receives
% to its peers after validating it.   Given the average transaction size is less than
% 100 bytes, it is almost as effecient to send the transaction as it is to send
% the notice (assuming a 20 byte transaction id)
% 
% Each node implements the following protocol:
% 
% 
%     onReceiveTransaction( from_peer, transaction )
%         if( isKnown( transaction.id() ) )
%             return
% 
%         markKnown( transaction.id() )
% 
%         if( !validate( transaction ) )
%            return
% 
%         for( peer : peers )
%           if( peer != from_peer )
%              send( peer, transaction )
% 
% 
%     onReceiveBlock( from_peer, block_summary )
%         if( isKnown( block_summary )
%             return
% 
%         full_block = reconstructFullBlcok( from_peer, block_summary )
%         if( !full_block ) disconnect from_peer
% 
%         markKnown( block_summary )
% 
%         if( !pushBlock( full_block ) ) disconnect from_peer
% 
%         for( peer : peers )
%            if( peer != from_peer )
%              send( peer, block_summary )
%              
% 
%      onConnect( new_peer, new_peer_head_block_num )
%         if( peers.size() >= max_peers )
%            send( new_peer, peers )
%            disconnect( new_peer )
%            return
%          
%         while( new_peer_head_block_num < our_head_block_num )
%            sendFullBlock( new_peer, ++new_peer_head_block_num )
% 
%         new_peer.synced = true
%         for( peer : peers )
%             send( peer, new_peer )
%    
%      onReceivePeers( from_peer, peers )
%         addToPotentialPeers( peers )
% 
%      onUpdateConnectionsTimer
%         if( peers.size() < desired_peers )
%           connect( random_potential_peer )
% 
%      onFullBlock( from_peer, full_block )
%         if( !pushBlock( full_block ) ) disconnect from_peer
% 
%      onStartup
%         init_potential_peers from config
%         start onUpdateConnectionsTimer
